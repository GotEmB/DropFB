// Generated by CoffeeScript 1.6.3
var currentTasks, express, expressServer, http, io, port, request, server, socket_io, _ref;

express = require("express");

http = require("http");

socket_io = require("socket.io");

request = require("request");

currentTasks = {};

expressServer = express();

expressServer.configure(function() {
  expressServer.use(express.bodyParser());
  expressServer.use(function(req, res, next) {
    req.url = (function() {
      switch (req.url) {
        case "/":
          return "/page.html";
        default:
          return req.url;
      }
    })();
    return next();
  });
  expressServer.use(express["static"]("" + __dirname + "/public", {
    maxAge: 0
  }, function(err) {
    return console.log("Static: " + err);
  }));
  return expressServer.use(expressServer.router);
});

server = http.createServer(expressServer);

io = socket_io.listen(server);

io.set("log level", 0);

io.sockets.on("connection", function(socket) {
  socket.on("handshake", function(_arg, callback) {
    var userId, _name;
    userId = _arg.userId;
    return callback({
      tasks: currentTasks[_name = socket.userId = userId] != null ? currentTasks[_name = socket.userId = userId] : currentTasks[_name] = []
    });
  });
  socket.on("addTask", function(_arg, callback) {
    var task;
    task = _arg.task;
    if (socket.userId == null) {
      return callback({
        success: false
      });
    }
    if (currentTasks[socket.userId].some(function(x) {
      return x.path === task.path;
    })) {
      return callback({
        success: false
      });
    }
    currentTasks[socket.userId].push(task);
    callback({
      success: true
    });
    return io.sockets.clients().filter(function(x) {
      return x !== socket && x.userId === socket.userId;
    }).forEach(function(x) {
      return x.emit("addTask", {
        task: task
      });
    });
  });
  socket.on("removeTask", function(_arg, callback) {
    var taskPath;
    taskPath = _arg.taskPath;
    if (socket.userId == null) {
      return callback({
        success: false
      });
    }
    if (!currentTasks[socket.userId].some(function(x) {
      return x.path === taskPath && x.status !== "posting";
    })) {
      return callback({
        success: false
      });
    }
    currentTasks[socket.userId] = currentTasks[socket.userId].filter(function(x) {
      return x.path !== taskPath;
    });
    callback({
      success: true
    });
    return io.sockets.clients().filter(function(x) {
      return x !== socket && x.userId === socket.userId;
    }).forEach(function(x) {
      return x.emit("removeTask", {
        taskPath: taskPath
      });
    });
  });
  socket.on("captionChanged", function(_arg) {
    var caption, taskPath;
    taskPath = _arg.taskPath, caption = _arg.caption;
    if (socket.userId == null) {
      return;
    }
    if (!currentTasks[socket.userId].some(function(x) {
      var _ref;
      return x.path === taskPath && ((_ref = x.status) !== "posting" && _ref !== "post_success" && _ref !== "post_failure");
    })) {
      return;
    }
    currentTasks[socket.userId].filter(function(x) {
      return x.path === taskPath;
    })[0].caption = caption;
    return io.sockets.clients().filter(function(x) {
      return x !== socket && x.userId === socket.userId;
    }).forEach(function(x) {
      return x.emit("captionChanged", {
        taskPath: taskPath,
        caption: caption
      });
    });
  });
  socket.on("uploadTask", function(_arg, callback) {
    var albumId, delay, fbAccessToken, form, r1, r2, si, task, taskPath;
    taskPath = _arg.taskPath, fbAccessToken = _arg.fbAccessToken, albumId = _arg.albumId, delay = _arg.delay;
    if (socket.userId == null) {
      return callback({
        success: false
      });
    }
    if (!currentTasks[socket.userId].some(function(x) {
      return x.path === taskPath;
    })) {
      return callback({
        success: false
      });
    }
    task = currentTasks[socket.userId].filter(function(x) {
      return x.path === taskPath;
    })[0];
    task.status = "posting";
    io.sockets.clients().filter(function(x) {
      return x !== socket && x.userId === socket.userId;
    }).forEach(function(x) {
      return x.emit("posting", {
        taskPath: taskPath
      });
    });
    if (task.type === "photo") {
      return setTimeout(function() {
        return request.post("https://graph.facebook.com/" + (albumId != null ? albumId : socket.userId) + "/photos", {
          form: {
            access_token: fbAccessToken,
            url: taskPath,
            name: task.caption
          }
        }, function(error, response, body) {
          body = (function() {
            try {
              return JSON.parse(body);
            } catch (_error) {
              return body;
            }
          })();
          callback({
            success: !((error != null) || (body.error != null))
          });
          task.status = !((error != null) || (body.error != null)) ? "post_success" : "post_failure";
          return io.sockets.clients().filter(function(x) {
            return x !== socket && x.userId === socket.userId;
          }).forEach(function(x) {
            return x.emit("uploadedTask", {
              taskPath: taskPath,
              success: !((error != null) || (body.error != null))
            });
          });
        });
      }, delay != null ? delay : 0);
    } else if (task.type === "video") {
      r2 = request.post("https://graph-video.facebook.com/me/videos");
      form = r2.form();
      form.append("access_token", fbAccessToken);
      form.append("name", task.caption);
      form.append("file", r1 = request.get(taskPath));
      si = void 0;
      r1.on("response", function(response) {
        var fileSize, oldProgress;
        io.sockets.clients().filter(function(x) {
          return x.userId === socket.userId;
        }).forEach(function(x) {
          return x.emit("transferring", {
            taskPath: taskPath
          });
        });
        fileSize = Number(response.Headers["content-length"]);
        oldProgress = {
          download: 0,
          upload: 0
        };
        return si = setInterval(function() {
          var _ref;
          task.downloadProgress = ((_ref = r1.response) != null ? _ref.connection.socket.bytesRead : void 0) / fileSize * 100;
          task.uploadProgress = r2.req.connection.socket._bytesDispatched / fileSize * 100;
          if (oldProgress.download === task.downloadProgress && oldProgress.upload === task.uploadProgress) {
            return;
          }
          return io.sockets.clients().filter(function(x) {
            return x.userId === socket.userId;
          }).forEach(function(x) {
            return x.volatile.emit("progress", {
              taskPath: taskPath,
              download: task.downloadProgress,
              upload: task.uploadProgress
            });
          });
        }, 100);
      });
      return r1.on("response", function(response) {
        task.downloadProgress = task.uploadProgress = 0;
        io.sockets.clients().filter(function(x) {
          return x.userId === socket.userId;
        }).forEach(function(x) {
          return x.volatile.emit("progress", {
            taskPath: taskPath,
            download: 0,
            upload: 0
          });
        });
        console.log({
          result: response
        });
        clearInterval(si);
        callback({
          success: true
        });
        task.status = "post_success";
        return io.sockets.clients().filter(function(x) {
          return x !== socket && x.userId === socket.userId;
        }).forEach(function(x) {
          return x.emit("uploadedTask", {
            taskPath: taskPath,
            success: true
          });
        });
      });
    }
  });
  return socket.on("failureAck", function(_arg, callback) {
    var taskPath;
    taskPath = _arg.taskPath;
    if (socket.userId == null) {
      return callback({
        success: false
      });
    }
    if (!currentTasks[socket.userId].some(function(x) {
      return x.path === taskPath;
    })) {
      return callback({
        success: false
      });
    }
    return io.sockets.clients().filter(function(x) {
      return x !== socket && x.userId === socket.userId;
    }).forEach(function(x) {
      return x.emit("failureAck", {
        taskPath: taskPath
      });
    });
  });
});

server.listen((port = (_ref = process.env.PORT) != null ? _ref : 5080), function() {
  return console.log("Listening on port " + port);
});
